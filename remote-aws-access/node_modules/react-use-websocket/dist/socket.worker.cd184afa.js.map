{"version":3,"sources":["worker/types.ts","worker/socket.worker.ts"],"names":[],"mappings":";AAAA,aAAA,IAAY,EAAZ,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,SAAY,GACV,EAAA,QAAA,UACA,EAAA,UAAA,YACA,EAAA,OAAA,SACA,EAAA,QAAA,UACA,EAAA,QAAA,UACA,EAAA,YAAA,cACA,EAAA,MAAA,QACA,EAAA,oBAAA,sBARF,CAAY,EAAA,QAAA,eAAA,QAAA,aAAY;;ACKxB,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IALA,IAAA,QAAA,QAAA,WAEI,UACA,UAEJ,KAAK,UAAY,SAAC,mBACR,OAAA,kBAAkB,KAAK,MACxB,KAAA,QAAA,aAAa,QACZ,QAAc,IAAd,UACI,MAAA,IAAI,MAAM,wCAEhB,UAAY,IAAI,UAAU,kBAAkB,KAAK,SAEjD,UAAU,OAAS,SAAC,GAClB,YAAY,CACV,KAAM,QAAA,aAAa,WAClB,OAEL,UAAU,QAAU,SAAC,GACnB,YAAY,CACV,KAAM,QAAA,aAAa,QAClB,OAEL,UAAU,QAAU,SAAC,GACnB,YAAY,CACV,KAAM,QAAA,aAAa,QACnB,QAAS,GACR,OAEL,UAAU,UAAY,SAAC,GACjB,GAAA,UAAW,CACP,IAAA,EAAY,UAAU,GACV,OAAd,GACF,YAAY,CACV,KAAM,QAAA,aAAa,QACnB,QAAS,GACR,WAGL,YAAY,CACV,KAAM,QAAA,aAAa,QACnB,QAAS,EAAQ,MAChB,OAIT,MAEG,KAAA,QAAA,aAAa,YACZ,QAAc,IAAd,UACI,MAAA,IAAI,MAAM,yDAEhB,UAAU,KAAK,kBAAkB,KAAK,SAExC,MAEG,KAAA,QAAA,aAAa,MACZ,QAAc,IAAd,UACI,MAAA,IAAI,MAAM,mDAEhB,UAAU,QAEZ,MAEG,KAAA,QAAA,aAAa,oBAChB,UAAY,KAAK,IAAI,kBAAkB,KAAK,QAAQ,KACpD,MAEF,QACQ,MAAA,IAAI,MAAM,gCAAgC","file":"socket.worker.cd184afa.js","sourceRoot":"../src","sourcesContent":["export enum MessageTypes {\n  Connect = 'Connect',\n  Connected = 'Connected',\n  Closed = 'Closed',\n  Errored = 'Errored',\n  Message = 'Message',\n  SendMessage = 'SendMessage',\n  Close = 'Close',\n  SetMessageProcessor = 'SetMessageProcessor',\n}\n","import { MessageTypes } from './types';\n\nlet webSocket: WebSocket;\nlet processor: (messageData: WebSocketEventMap['message']) => any;\n\nself.onmessage = (mainThreadMessage: any) => {\n  switch (mainThreadMessage.data.type as MessageTypes) {\n    case MessageTypes.Connect:\n      if (webSocket !== undefined) {\n        throw new Error('A WebSocket has already been created');\n      } else {\n        webSocket = new WebSocket(mainThreadMessage.data.payload);\n\n        webSocket.onopen = (message: WebSocketEventMap['open']) => {\n          postMessage({\n            type: MessageTypes.Connected,\n          }, null);\n        };\n        webSocket.onclose = (closeEvent: WebSocketEventMap['close']) => {\n          postMessage({\n            type: MessageTypes.Closed,\n          }, null);\n        };\n        webSocket.onerror = (errorEvent: WebSocketEventMap['error']) => {\n          postMessage({\n            type: MessageTypes.Errored,\n            payload: errorEvent,\n          }, null);\n        };\n        webSocket.onmessage = (message: WebSocketEventMap['message']) => {\n          if (processor) {\n            const processed = processor(message);\n            if (processed !== null) {\n              postMessage({\n                type: MessageTypes.Message,\n                payload: processed,\n              }, null);\n            }\n          } else {\n            postMessage({\n              type: MessageTypes.Message,\n              payload: message.data,\n            }, null);\n          }\n        };\n      }\n      break;\n\n    case MessageTypes.SendMessage:\n      if (webSocket === undefined) {\n        throw new Error('Cannot send a message until a socket has been created');\n      } else {\n        webSocket.send(mainThreadMessage.data.payload);\n      }\n      break;\n\n    case MessageTypes.Close:\n      if (webSocket === undefined) {\n        throw new Error('Cannot close a socket until it has been created');\n      } else {\n        webSocket.close();\n      }\n      break;\n  \n    case MessageTypes.SetMessageProcessor:\n      processor = eval('('+mainThreadMessage.data.payload+')');\n      break;\n\n    default:\n      throw new Error(`Unexpected message received: ${mainThreadMessage}`);\n  }\n};\n"]}